

JIT Error Messages:
https://raw.githubusercontent.com/dotnet/coreclr/65456c070ffbc97f14c1c32318dabc221646d8d6/src/jit/importer.cpp
JIT ETW Events:
https://msdn.microsoft.com/en-us/library/ff356158(v=vs.110).aspx


Release TODOs:

Icons
Documentation

check Arrays for signatures and inlining

inside static classes
inside extension methods
calling extension methods
inside method with nullable return

TODOs:

"Method is marked as no inline or has a cached result" -> use other failReason

multiple calls per method?

filter per assembly / handle multiple assemblies
Check with large open source solutions (protobuf-net,...)
Check if parallel analyze makes sense
settings/data folder?

CI Build?

save all jit info or just for the assembly + directly referenced?
UI for analyzer progress?
Unit Tests for Analyzer, Serialization, Highlighter?


Further:
analyze only single method?
generics support
.net core support (split InliningAnalyzer/JitCompiler Assemblies first)
support for operators
check field initializer (how to force jit?)
analyze whole solution
Incremental analyze?
Analyze Tail-Calls?
detect if code has been changed and disable
support changing jitter in options?
save last result and load it on startup?
support unity?


InliningAnalyzer-a4c401b8-a782-441a-8548-e7a44aeb23d1

Want to know if a method will be inlined by the JIT Compiler? Inlining Analyzer highlights all method calls right in the source code and also displays the reason for a failed inline as
given by the JIT Compiler.


What is Inlining and why should I care?
Inlining [https://en.wikipedia.org/wiki/Inline_expansion] is a compiler optimization that replaces a function call site with the body of the callee. In the Common Language Runtime, this is done by the JIT Compiler. For performance-critical code, it can be important to know if a method will be inlined or not. More Inlining is usually better, but not always. If you tweak your code the get a method to be inlined, always use a Profiler or a benchmarking library to test if it really does make a difference for your scenario.

Unfortunately it is not possible to determine if a method will be inlined or not from the source code alone, as the decisions of the JIT compiler not only depend on some clear-cut rules (e.g. no exception handling within the method) but also on information that is only available at runtime (like the native code size of a method). Therefore it is not easy way to find out if a method will be inlined, 
usually this is done by running the application and either tracing and interpreting ETW events manually or by looking at the compiled native code with a debugger. Both options are not exactly convenient, therefore Inlining Analyzer saves you from doing all this work manually.

How does it work?
When you run the Inlining Analyzer through the menu it builds your project, loads the resulting assembly into a seperate process, forces a JIT compilation of all methods and collects the ETW trace events emitted by the JIT Compiler [https://docs.microsoft.com/en-us/dotnet/framework/performance/jit-tracing-etw-events]. 
The information gathered from these events (inlining succeeded/failed, the reason and the IL size) is then mapped onto the corresponding method calls in the source code editor. Inlined methods are highlighted green, not inlined methods red and the tooltip of the method contains the fail reason and IL size (if available).

Can I change the colors for the highlighting?
Of course, just search for "Inlining Analyzer" in the "Fonts and Colors" options page:

Why is a File Open dialog box displayed after I run the Analyzer?
If the resulting assembly can not be determined automatically, e.g. because the project creates multiple assemblies, you need to select the assembly to be analyzed manually.

Known Issues (will be addressed in future releases):
* No support for Generics (both as callers and callees), these methods will not be highlighted
* Some edge cases with non-generic method calls not highlighted
* No support for implicit method calls that are not directly visible in the source code (overloaded operators, anonymous methods, lambdas, async/await,...)
* No support for .NET Core
